{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nconst _excluded = [\"animationIn\", \"animationInTiming\", \"animationOut\", \"animationOutTiming\", \"avoidKeyboard\", \"coverScreen\", \"hasBackdrop\", \"backdropColor\", \"backdropOpacity\", \"backdropTransitionInTiming\", \"backdropTransitionOutTiming\", \"customBackdrop\", \"children\", \"isVisible\", \"onModalShow\", \"onBackButtonPress\", \"useNativeDriver\", \"propagateSwipe\", \"style\"],\n  _excluded2 = [\"testID\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport KeyboardAvoidingView from \"react-native-web/dist/exports/KeyboardAvoidingView\";\nimport Modal from \"react-native-web/dist/exports/Modal\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport View from \"react-native-web/dist/exports/View\";\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage } from './utils';\nimport styles from './modal.style';\ninitializeAnimations();\nconst defaultProps = {\n  animationIn: 'slideInUp',\n  animationInTiming: 300,\n  animationOut: 'slideOutDown',\n  animationOutTiming: 300,\n  avoidKeyboard: false,\n  coverScreen: true,\n  hasBackdrop: true,\n  backdropColor: 'black',\n  backdropOpacity: 0.7,\n  backdropTransitionInTiming: 300,\n  backdropTransitionOutTiming: 300,\n  customBackdrop: null,\n  useNativeDriver: false,\n  deviceHeight: null,\n  deviceWidth: null,\n  hideModalContentWhileAnimating: false,\n  propagateSwipe: false,\n  isVisible: false,\n  panResponderThreshold: 4,\n  swipeThreshold: 100,\n  onModalShow: () => null,\n  onModalWillShow: () => null,\n  onModalHide: () => null,\n  onModalWillHide: () => null,\n  onBackdropPress: () => null,\n  onBackButtonPress: () => null,\n  scrollTo: null,\n  scrollOffset: 0,\n  scrollOffsetMax: 0,\n  scrollHorizontal: false,\n  statusBarTranslucent: false,\n  supportedOrientations: ['portrait', 'landscape']\n};\nconst extractAnimationFromProps = props => ({\n  animationIn: props.animationIn,\n  animationOut: props.animationOut\n});\nexport class ReactNativeModal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      showContent: true,\n      isVisible: false,\n      deviceWidth: Dimensions.get('window').width,\n      deviceHeight: Dimensions.get('window').height,\n      isSwipeable: !!this.props.swipeDirection,\n      pan: null\n    };\n    this.isTransitioning = false;\n    this.inSwipeClosingState = false;\n    this.currentSwipingDirection = null;\n    this.panResponder = null;\n    this.didUpdateDimensionsEmitter = null;\n    this.interactionHandle = null;\n    this.getDeviceHeight = () => this.props.deviceHeight || this.state.deviceHeight;\n    this.getDeviceWidth = () => this.props.deviceWidth || this.state.deviceWidth;\n    this.onBackButtonPress = () => {\n      if (this.props.onBackButtonPress && this.props.isVisible) {\n        this.props.onBackButtonPress();\n        return true;\n      }\n      return false;\n    };\n    this.shouldPropagateSwipe = (evt, gestureState) => {\n      return typeof this.props.propagateSwipe === 'function' ? this.props.propagateSwipe(evt, gestureState) : this.props.propagateSwipe;\n    };\n    this.buildPanResponder = () => {\n      let animEvt = null;\n      this.panResponder = PanResponder.create({\n        onMoveShouldSetPanResponder: (evt, gestureState) => {\n          if (!this.shouldPropagateSwipe(evt, gestureState)) {\n            const shouldSetPanResponder = Math.abs(gestureState.dx) >= this.props.panResponderThreshold || Math.abs(gestureState.dy) >= this.props.panResponderThreshold;\n            if (shouldSetPanResponder && this.props.onSwipeStart) {\n              this.props.onSwipeStart(gestureState);\n            }\n            this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n            animEvt = this.createAnimationEventForSwipe();\n            return shouldSetPanResponder;\n          }\n          return false;\n        },\n        onStartShouldSetPanResponder: (e, gestureState) => {\n          const hasScrollableView = e._dispatchInstances && e._dispatchInstances.some(instance => /scrollview|flatlist/i.test(instance.type));\n          if (hasScrollableView && this.shouldPropagateSwipe(e, gestureState) && this.props.scrollTo && this.props.scrollOffset > 0) {\n            return false;\n          }\n          if (this.props.onSwipeStart) {\n            this.props.onSwipeStart(gestureState);\n          }\n          this.currentSwipingDirection = null;\n          return true;\n        },\n        onPanResponderMove: (evt, gestureState) => {\n          if (!this.currentSwipingDirection) {\n            if (gestureState.dx === 0 && gestureState.dy === 0) {\n              return;\n            }\n            this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n            animEvt = this.createAnimationEventForSwipe();\n          }\n          if (this.isSwipeDirectionAllowed(gestureState)) {\n            const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n            this.backdropRef && this.backdropRef.transitionTo({\n              opacity: this.props.backdropOpacity * newOpacityFactor\n            });\n            animEvt(evt, gestureState);\n            if (this.props.onSwipeMove) {\n              this.props.onSwipeMove(newOpacityFactor, gestureState);\n            }\n          } else {\n            if (this.props.scrollTo) {\n              if (this.props.scrollHorizontal) {\n                let offsetX = -gestureState.dx;\n                if (offsetX > this.props.scrollOffsetMax) {\n                  offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                }\n                this.props.scrollTo({\n                  x: offsetX,\n                  animated: false\n                });\n              } else {\n                let offsetY = -gestureState.dy;\n                if (offsetY > this.props.scrollOffsetMax) {\n                  offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                }\n                this.props.scrollTo({\n                  y: offsetY,\n                  animated: false\n                });\n              }\n            }\n          }\n        },\n        onPanResponderRelease: (evt, gestureState) => {\n          const accDistance = this.getAccDistancePerDirection(gestureState);\n          if (accDistance > this.props.swipeThreshold && this.isSwipeDirectionAllowed(gestureState)) {\n            if (this.props.onSwipeComplete) {\n              this.inSwipeClosingState = true;\n              this.props.onSwipeComplete({\n                swipingDirection: this.getSwipingDirection(gestureState)\n              }, gestureState);\n              return;\n            }\n            if (this.props.onSwipe) {\n              this.inSwipeClosingState = true;\n              this.props.onSwipe();\n              return;\n            }\n          }\n          if (this.props.onSwipeCancel) {\n            this.props.onSwipeCancel(gestureState);\n          }\n          if (this.backdropRef) {\n            this.backdropRef.transitionTo({\n              opacity: this.props.backdropOpacity\n            });\n          }\n          Animated.spring(this.state.pan, {\n            toValue: {\n              x: 0,\n              y: 0\n            },\n            bounciness: 0,\n            useNativeDriver: false\n          }).start();\n          if (this.props.scrollTo) {\n            if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n              this.props.scrollTo({\n                y: this.props.scrollOffsetMax,\n                animated: true\n              });\n            }\n          }\n        }\n      });\n    };\n    this.getAccDistancePerDirection = gestureState => {\n      switch (this.currentSwipingDirection) {\n        case 'up':\n          return -gestureState.dy;\n        case 'down':\n          return gestureState.dy;\n        case 'right':\n          return gestureState.dx;\n        case 'left':\n          return -gestureState.dx;\n        default:\n          return 0;\n      }\n    };\n    this.getSwipingDirection = gestureState => {\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n        return gestureState.dx > 0 ? 'right' : 'left';\n      }\n      return gestureState.dy > 0 ? 'down' : 'up';\n    };\n    this.calcDistancePercentage = gestureState => {\n      switch (this.currentSwipingDirection) {\n        case 'down':\n          return (gestureState.moveY - gestureState.y0) / ((this.props.deviceHeight || this.state.deviceHeight) - gestureState.y0);\n        case 'up':\n          return reversePercentage(gestureState.moveY / gestureState.y0);\n        case 'left':\n          return reversePercentage(gestureState.moveX / gestureState.x0);\n        case 'right':\n          return (gestureState.moveX - gestureState.x0) / ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0);\n        default:\n          return 0;\n      }\n    };\n    this.createAnimationEventForSwipe = () => {\n      if (this.currentSwipingDirection === 'right' || this.currentSwipingDirection === 'left') {\n        return Animated.event([null, {\n          dx: this.state.pan.x\n        }], {\n          useNativeDriver: false\n        });\n      } else {\n        return Animated.event([null, {\n          dy: this.state.pan.y\n        }], {\n          useNativeDriver: false\n        });\n      }\n    };\n    this.isDirectionIncluded = direction => {\n      return Array.isArray(this.props.swipeDirection) ? this.props.swipeDirection.includes(direction) : this.props.swipeDirection === direction;\n    };\n    this.isSwipeDirectionAllowed = ({\n      dy,\n      dx\n    }) => {\n      const draggedDown = dy > 0;\n      const draggedUp = dy < 0;\n      const draggedLeft = dx < 0;\n      const draggedRight = dx > 0;\n      if (this.currentSwipingDirection === 'up' && this.isDirectionIncluded('up') && draggedUp) {\n        return true;\n      } else if (this.currentSwipingDirection === 'down' && this.isDirectionIncluded('down') && draggedDown) {\n        return true;\n      } else if (this.currentSwipingDirection === 'right' && this.isDirectionIncluded('right') && draggedRight) {\n        return true;\n      } else if (this.currentSwipingDirection === 'left' && this.isDirectionIncluded('left') && draggedLeft) {\n        return true;\n      }\n      return false;\n    };\n    this.handleDimensionsUpdate = () => {\n      if (!this.props.deviceHeight && !this.props.deviceWidth) {\n        const deviceWidth = Dimensions.get('window').width;\n        const deviceHeight = Dimensions.get('window').height;\n        if (deviceWidth !== this.state.deviceWidth || deviceHeight !== this.state.deviceHeight) {\n          this.setState({\n            deviceWidth,\n            deviceHeight\n          });\n        }\n      }\n    };\n    this.open = () => {\n      if (this.isTransitioning) {\n        return;\n      }\n      this.isTransitioning = true;\n      if (this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: this.props.backdropOpacity\n        }, this.props.backdropTransitionInTiming);\n      }\n      if (this.state.isSwipeable) {\n        this.state.pan.setValue({\n          x: 0,\n          y: 0\n        });\n      }\n      if (this.contentRef) {\n        this.props.onModalWillShow && this.props.onModalWillShow();\n        if (this.interactionHandle == null) {\n          this.interactionHandle = InteractionManager.createInteractionHandle();\n        }\n        this.contentRef.animate(this.animationIn, this.props.animationInTiming).then(() => {\n          this.isTransitioning = false;\n          if (this.interactionHandle) {\n            InteractionManager.clearInteractionHandle(this.interactionHandle);\n            this.interactionHandle = null;\n          }\n          if (!this.props.isVisible) {\n            this.close();\n          } else {\n            this.props.onModalShow();\n          }\n        });\n      }\n    };\n    this.close = () => {\n      if (this.isTransitioning) {\n        return;\n      }\n      this.isTransitioning = true;\n      if (this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: 0\n        }, this.props.backdropTransitionOutTiming);\n      }\n      let animationOut = this.animationOut;\n      if (this.inSwipeClosingState) {\n        this.inSwipeClosingState = false;\n        if (this.currentSwipingDirection === 'up') {\n          animationOut = 'slideOutUp';\n        } else if (this.currentSwipingDirection === 'down') {\n          animationOut = 'slideOutDown';\n        } else if (this.currentSwipingDirection === 'right') {\n          animationOut = 'slideOutRight';\n        } else if (this.currentSwipingDirection === 'left') {\n          animationOut = 'slideOutLeft';\n        }\n      }\n      if (this.contentRef) {\n        this.props.onModalWillHide && this.props.onModalWillHide();\n        if (this.interactionHandle == null) {\n          this.interactionHandle = InteractionManager.createInteractionHandle();\n        }\n        this.contentRef.animate(animationOut, this.props.animationOutTiming).then(() => {\n          this.isTransitioning = false;\n          if (this.interactionHandle) {\n            InteractionManager.clearInteractionHandle(this.interactionHandle);\n            this.interactionHandle = null;\n          }\n          if (this.props.isVisible) {\n            this.open();\n          } else {\n            this.setState({\n              showContent: false\n            }, () => {\n              this.setState({\n                isVisible: false\n              }, () => {\n                this.props.onModalHide();\n              });\n            });\n          }\n        });\n      }\n    };\n    this.makeBackdrop = () => {\n      if (!this.props.hasBackdrop) {\n        return null;\n      }\n      if (this.props.customBackdrop && !React.isValidElement(this.props.customBackdrop)) {\n        console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n      }\n      const {\n        customBackdrop,\n        backdropColor,\n        useNativeDriver,\n        useNativeDriverForBackdrop,\n        onBackdropPress\n      } = this.props;\n      const hasCustomBackdrop = !!this.props.customBackdrop;\n      const backdropComputedStyle = [{\n        width: this.getDeviceWidth(),\n        height: this.getDeviceHeight(),\n        backgroundColor: this.state.showContent && !hasCustomBackdrop ? backdropColor : 'transparent'\n      }];\n      const backdropWrapper = React.createElement(animatable.View, {\n        ref: ref => this.backdropRef = ref,\n        useNativeDriver: useNativeDriverForBackdrop !== undefined ? useNativeDriverForBackdrop : useNativeDriver,\n        style: [styles.backdrop, backdropComputedStyle]\n      }, hasCustomBackdrop && customBackdrop);\n      if (hasCustomBackdrop) {\n        return backdropWrapper;\n      }\n      return React.createElement(TouchableWithoutFeedback, {\n        onPress: onBackdropPress\n      }, backdropWrapper);\n    };\n    const {\n      animationIn,\n      animationOut\n    } = buildAnimations(extractAnimationFromProps(props));\n    this.animationIn = animationIn;\n    this.animationOut = animationOut;\n    if (this.state.isSwipeable) {\n      this.state = _objectSpread(_objectSpread({}, this.state), {}, {\n        pan: new Animated.ValueXY()\n      });\n      this.buildPanResponder();\n    }\n    if (props.isVisible) {\n      this.state = _objectSpread(_objectSpread({}, this.state), {}, {\n        isVisible: true,\n        showContent: true\n      });\n    }\n  }\n  static getDerivedStateFromProps(nextProps, state) {\n    if (!state.isVisible && nextProps.isVisible) {\n      return {\n        isVisible: true,\n        showContent: true\n      };\n    }\n    return null;\n  }\n  componentDidMount() {\n    if (this.props.onSwipe) {\n      console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n    }\n    this.didUpdateDimensionsEmitter = DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    if (this.state.isVisible) {\n      this.open();\n    }\n    BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n  }\n  componentWillUnmount() {\n    BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n    if (this.didUpdateDimensionsEmitter) {\n      this.didUpdateDimensionsEmitter.remove();\n    }\n    if (this.interactionHandle) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n      this.interactionHandle = null;\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {\n      const {\n        animationIn,\n        animationOut\n      } = buildAnimations(extractAnimationFromProps(this.props));\n      this.animationIn = animationIn;\n      this.animationOut = animationOut;\n    }\n    if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {\n      this.backdropRef.transitionTo({\n        opacity: this.props.backdropOpacity\n      }, this.props.backdropTransitionInTiming);\n    }\n    if (this.props.isVisible && !prevProps.isVisible) {\n      this.open();\n    } else if (!this.props.isVisible && prevProps.isVisible) {\n      this.close();\n    }\n  }\n  render() {\n    const _this$props = this.props,\n      {\n        animationIn,\n        animationInTiming,\n        animationOut,\n        animationOutTiming,\n        avoidKeyboard,\n        coverScreen,\n        hasBackdrop,\n        backdropColor,\n        backdropOpacity,\n        backdropTransitionInTiming,\n        backdropTransitionOutTiming,\n        customBackdrop,\n        children,\n        isVisible,\n        onModalShow,\n        onBackButtonPress,\n        useNativeDriver,\n        propagateSwipe,\n        style\n      } = _this$props,\n      otherProps = _objectWithoutProperties(_this$props, _excluded);\n    const {\n        testID\n      } = otherProps,\n      containerProps = _objectWithoutProperties(otherProps, _excluded2);\n    const computedStyle = [{\n      margin: this.getDeviceWidth() * 0.05,\n      transform: [{\n        translateY: 0\n      }]\n    }, styles.content, style];\n    let panHandlers = {};\n    let panPosition = {};\n    if (this.state.isSwipeable) {\n      panHandlers = _objectSpread({}, this.panResponder.panHandlers);\n      if (useNativeDriver) {\n        panPosition = {\n          transform: this.state.pan.getTranslateTransform()\n        };\n      } else {\n        panPosition = this.state.pan.getLayout();\n      }\n    }\n    const _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? (React.createElement(animatable.View, null)) : children;\n    const containerView = React.createElement(animatable.View, Object.assign({}, panHandlers, {\n      ref: ref => this.contentRef = ref,\n      style: [panPosition, computedStyle],\n      pointerEvents: \"box-none\",\n      useNativeDriver: useNativeDriver\n    }, containerProps), _children);\n    if (!coverScreen && this.state.isVisible) {\n      return React.createElement(View, {\n        pointerEvents: \"box-none\",\n        style: [styles.backdrop, styles.containerBox]\n      }, this.makeBackdrop(), containerView);\n    }\n    return React.createElement(Modal, Object.assign({\n      transparent: true,\n      animationType: 'none',\n      visible: this.state.isVisible,\n      onRequestClose: onBackButtonPress\n    }, otherProps), this.makeBackdrop(), avoidKeyboard ? (React.createElement(KeyboardAvoidingView, {\n      behavior: Platform.OS === 'ios' ? 'padding' : undefined,\n      pointerEvents: \"box-none\",\n      style: computedStyle.concat([{\n        margin: 0\n      }])\n    }, containerView)) : containerView);\n  }\n}\nReactNativeModal.propTypes = {\n  animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationInTiming: PropTypes.number,\n  animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationOutTiming: PropTypes.number,\n  avoidKeyboard: PropTypes.bool,\n  coverScreen: PropTypes.bool,\n  hasBackdrop: PropTypes.bool,\n  backdropColor: PropTypes.string,\n  backdropOpacity: PropTypes.number,\n  backdropTransitionInTiming: PropTypes.number,\n  backdropTransitionOutTiming: PropTypes.number,\n  customBackdrop: PropTypes.node,\n  children: PropTypes.node.isRequired,\n  deviceHeight: PropTypes.number,\n  deviceWidth: PropTypes.number,\n  isVisible: PropTypes.bool.isRequired,\n  hideModalContentWhileAnimating: PropTypes.bool,\n  propagateSwipe: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n  onModalShow: PropTypes.func,\n  onModalWillShow: PropTypes.func,\n  onModalHide: PropTypes.func,\n  onModalWillHide: PropTypes.func,\n  onBackButtonPress: PropTypes.func,\n  onBackdropPress: PropTypes.func,\n  panResponderThreshold: PropTypes.number,\n  onSwipeStart: PropTypes.func,\n  onSwipeMove: PropTypes.func,\n  onSwipeComplete: PropTypes.func,\n  onSwipeCancel: PropTypes.func,\n  swipeThreshold: PropTypes.number,\n  swipeDirection: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])), PropTypes.oneOf(['up', 'down', 'left', 'right'])]),\n  useNativeDriver: PropTypes.bool,\n  useNativeDriverForBackdrop: PropTypes.bool,\n  style: PropTypes.any,\n  scrollTo: PropTypes.func,\n  scrollOffset: PropTypes.number,\n  scrollOffsetMax: PropTypes.number,\n  scrollHorizontal: PropTypes.bool,\n  supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))\n};\nReactNativeModal.defaultProps = defaultProps;\nexport default ReactNativeModal;","map":{"version":3,"names":["React","Animated","DeviceEventEmitter","Dimensions","InteractionManager","KeyboardAvoidingView","Modal","PanResponder","BackHandler","Platform","TouchableWithoutFeedback","View","PropTypes","animatable","initializeAnimations","buildAnimations","reversePercentage","styles","defaultProps","animationIn","animationInTiming","animationOut","animationOutTiming","avoidKeyboard","coverScreen","hasBackdrop","backdropColor","backdropOpacity","backdropTransitionInTiming","backdropTransitionOutTiming","customBackdrop","useNativeDriver","deviceHeight","deviceWidth","hideModalContentWhileAnimating","propagateSwipe","isVisible","panResponderThreshold","swipeThreshold","onModalShow","onModalWillShow","onModalHide","onModalWillHide","onBackdropPress","onBackButtonPress","scrollTo","scrollOffset","scrollOffsetMax","scrollHorizontal","statusBarTranslucent","supportedOrientations","extractAnimationFromProps","props","ReactNativeModal","Component","constructor","state","showContent","get","width","height","isSwipeable","swipeDirection","pan","isTransitioning","inSwipeClosingState","currentSwipingDirection","panResponder","didUpdateDimensionsEmitter","interactionHandle","getDeviceHeight","getDeviceWidth","shouldPropagateSwipe","evt","gestureState","buildPanResponder","animEvt","create","onMoveShouldSetPanResponder","shouldSetPanResponder","Math","abs","dx","dy","onSwipeStart","getSwipingDirection","createAnimationEventForSwipe","onStartShouldSetPanResponder","e","hasScrollableView","_dispatchInstances","some","instance","test","type","onPanResponderMove","isSwipeDirectionAllowed","newOpacityFactor","calcDistancePercentage","backdropRef","transitionTo","opacity","onSwipeMove","offsetX","x","animated","offsetY","y","onPanResponderRelease","accDistance","getAccDistancePerDirection","onSwipeComplete","swipingDirection","onSwipe","onSwipeCancel","spring","toValue","bounciness","start","moveY","y0","moveX","x0","event","isDirectionIncluded","direction","Array","isArray","includes","draggedDown","draggedUp","draggedLeft","draggedRight","handleDimensionsUpdate","setState","open","setValue","contentRef","createInteractionHandle","animate","then","clearInteractionHandle","close","makeBackdrop","isValidElement","console","warn","useNativeDriverForBackdrop","hasCustomBackdrop","backdropComputedStyle","backgroundColor","backdropWrapper","createElement","ref","undefined","style","backdrop","onPress","_objectSpread","ValueXY","getDerivedStateFromProps","nextProps","componentDidMount","addListener","addEventListener","componentWillUnmount","removeEventListener","remove","componentDidUpdate","prevProps","render","_this$props","children","otherProps","_objectWithoutProperties","_excluded","testID","containerProps","_excluded2","computedStyle","margin","transform","translateY","content","panHandlers","panPosition","getTranslateTransform","getLayout","_children","containerView","Object","assign","pointerEvents","containerBox","transparent","animationType","visible","onRequestClose","behavior","OS","concat","propTypes","oneOfType","string","object","number","bool","node","isRequired","func","arrayOf","oneOf","any"],"sources":["/home/luigi/Ãrea de Trabalho/glpi-app-react/node_modules/react-native-modal/dist/modal.js"],"sourcesContent":["import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, InteractionManager, KeyboardAvoidingView, Modal, PanResponder, BackHandler, Platform, TouchableWithoutFeedback, View, } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage, } from './utils';\nimport styles from './modal.style';\n// Override default react-native-animatable animations\ninitializeAnimations();\nconst defaultProps = {\n    animationIn: 'slideInUp',\n    animationInTiming: 300,\n    animationOut: 'slideOutDown',\n    animationOutTiming: 300,\n    avoidKeyboard: false,\n    coverScreen: true,\n    hasBackdrop: true,\n    backdropColor: 'black',\n    backdropOpacity: 0.7,\n    backdropTransitionInTiming: 300,\n    backdropTransitionOutTiming: 300,\n    customBackdrop: null,\n    useNativeDriver: false,\n    deviceHeight: null,\n    deviceWidth: null,\n    hideModalContentWhileAnimating: false,\n    propagateSwipe: false,\n    isVisible: false,\n    panResponderThreshold: 4,\n    swipeThreshold: 100,\n    onModalShow: (() => null),\n    onModalWillShow: (() => null),\n    onModalHide: (() => null),\n    onModalWillHide: (() => null),\n    onBackdropPress: (() => null),\n    onBackButtonPress: (() => null),\n    scrollTo: null,\n    scrollOffset: 0,\n    scrollOffsetMax: 0,\n    scrollHorizontal: false,\n    statusBarTranslucent: false,\n    supportedOrientations: ['portrait', 'landscape'],\n};\nconst extractAnimationFromProps = (props) => ({\n    animationIn: props.animationIn,\n    animationOut: props.animationOut,\n});\nexport class ReactNativeModal extends React.Component {\n    constructor(props) {\n        super(props);\n        // We use an internal state for keeping track of the modal visibility: this allows us to keep\n        // the modal visible during the exit animation, even if the user has already change the\n        // isVisible prop to false.\n        // We store in the state the device width and height so that we can update the modal on\n        // device rotation.\n        this.state = {\n            showContent: true,\n            isVisible: false,\n            deviceWidth: Dimensions.get('window').width,\n            deviceHeight: Dimensions.get('window').height,\n            isSwipeable: !!this.props.swipeDirection,\n            pan: null,\n        };\n        this.isTransitioning = false;\n        this.inSwipeClosingState = false;\n        this.currentSwipingDirection = null;\n        this.panResponder = null;\n        this.didUpdateDimensionsEmitter = null;\n        this.interactionHandle = null;\n        this.getDeviceHeight = () => this.props.deviceHeight || this.state.deviceHeight;\n        this.getDeviceWidth = () => this.props.deviceWidth || this.state.deviceWidth;\n        this.onBackButtonPress = () => {\n            if (this.props.onBackButtonPress && this.props.isVisible) {\n                this.props.onBackButtonPress();\n                return true;\n            }\n            return false;\n        };\n        this.shouldPropagateSwipe = (evt, gestureState) => {\n            return typeof this.props.propagateSwipe === 'function'\n                ? this.props.propagateSwipe(evt, gestureState)\n                : this.props.propagateSwipe;\n        };\n        this.buildPanResponder = () => {\n            let animEvt = null;\n            this.panResponder = PanResponder.create({\n                onMoveShouldSetPanResponder: (evt, gestureState) => {\n                    // Use propagateSwipe to allow inner content to scroll. See PR:\n                    // https://github.com/react-native-community/react-native-modal/pull/246\n                    if (!this.shouldPropagateSwipe(evt, gestureState)) {\n                        // The number \"4\" is just a good tradeoff to make the panResponder\n                        // work correctly even when the modal has touchable buttons.\n                        // However, if you want to overwrite this and choose for yourself,\n                        // set panResponderThreshold in the props.\n                        // For reference:\n                        // https://github.com/react-native-community/react-native-modal/pull/197\n                        const shouldSetPanResponder = Math.abs(gestureState.dx) >= this.props.panResponderThreshold ||\n                            Math.abs(gestureState.dy) >= this.props.panResponderThreshold;\n                        if (shouldSetPanResponder && this.props.onSwipeStart) {\n                            this.props.onSwipeStart(gestureState);\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                        return shouldSetPanResponder;\n                    }\n                    return false;\n                },\n                onStartShouldSetPanResponder: (e, gestureState) => {\n                    const hasScrollableView = e._dispatchInstances &&\n                        e._dispatchInstances.some((instance) => /scrollview|flatlist/i.test(instance.type));\n                    if (hasScrollableView &&\n                        this.shouldPropagateSwipe(e, gestureState) &&\n                        this.props.scrollTo &&\n                        this.props.scrollOffset > 0) {\n                        return false; // user needs to be able to scroll content back up\n                    }\n                    if (this.props.onSwipeStart) {\n                        this.props.onSwipeStart(gestureState);\n                    }\n                    // Cleared so that onPanResponderMove can wait to have some delta\n                    // to work with\n                    this.currentSwipingDirection = null;\n                    return true;\n                },\n                onPanResponderMove: (evt, gestureState) => {\n                    // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n                    // The direction to which the user is swiping until some move have been done\n                    if (!this.currentSwipingDirection) {\n                        if (gestureState.dx === 0 && gestureState.dy === 0) {\n                            return;\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                    }\n                    if (this.isSwipeDirectionAllowed(gestureState)) {\n                        // Dim the background while swiping the modal\n                        const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n                        this.backdropRef &&\n                            this.backdropRef.transitionTo({\n                                opacity: this.props.backdropOpacity * newOpacityFactor,\n                            });\n                        animEvt(evt, gestureState);\n                        if (this.props.onSwipeMove) {\n                            this.props.onSwipeMove(newOpacityFactor, gestureState);\n                        }\n                    }\n                    else {\n                        if (this.props.scrollTo) {\n                            if (this.props.scrollHorizontal) {\n                                let offsetX = -gestureState.dx;\n                                if (offsetX > this.props.scrollOffsetMax) {\n                                    offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ x: offsetX, animated: false });\n                            }\n                            else {\n                                let offsetY = -gestureState.dy;\n                                if (offsetY > this.props.scrollOffsetMax) {\n                                    offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ y: offsetY, animated: false });\n                            }\n                        }\n                    }\n                },\n                onPanResponderRelease: (evt, gestureState) => {\n                    // Call the onSwipe prop if the threshold has been exceeded on the right direction\n                    const accDistance = this.getAccDistancePerDirection(gestureState);\n                    if (accDistance > this.props.swipeThreshold &&\n                        this.isSwipeDirectionAllowed(gestureState)) {\n                        if (this.props.onSwipeComplete) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipeComplete({\n                                swipingDirection: this.getSwipingDirection(gestureState),\n                            }, gestureState);\n                            return;\n                        }\n                        // Deprecated. Remove later.\n                        if (this.props.onSwipe) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipe();\n                            return;\n                        }\n                    }\n                    //Reset backdrop opacity and modal position\n                    if (this.props.onSwipeCancel) {\n                        this.props.onSwipeCancel(gestureState);\n                    }\n                    if (this.backdropRef) {\n                        this.backdropRef.transitionTo({\n                            opacity: this.props.backdropOpacity,\n                        });\n                    }\n                    Animated.spring(this.state.pan, {\n                        toValue: { x: 0, y: 0 },\n                        bounciness: 0,\n                        useNativeDriver: false,\n                    }).start();\n                    if (this.props.scrollTo) {\n                        if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n                            this.props.scrollTo({\n                                y: this.props.scrollOffsetMax,\n                                animated: true,\n                            });\n                        }\n                    }\n                },\n            });\n        };\n        this.getAccDistancePerDirection = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'up':\n                    return -gestureState.dy;\n                case 'down':\n                    return gestureState.dy;\n                case 'right':\n                    return gestureState.dx;\n                case 'left':\n                    return -gestureState.dx;\n                default:\n                    return 0;\n            }\n        };\n        this.getSwipingDirection = (gestureState) => {\n            if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n                return gestureState.dx > 0 ? 'right' : 'left';\n            }\n            return gestureState.dy > 0 ? 'down' : 'up';\n        };\n        this.calcDistancePercentage = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'down':\n                    return ((gestureState.moveY - gestureState.y0) /\n                        ((this.props.deviceHeight || this.state.deviceHeight) -\n                            gestureState.y0));\n                case 'up':\n                    return reversePercentage(gestureState.moveY / gestureState.y0);\n                case 'left':\n                    return reversePercentage(gestureState.moveX / gestureState.x0);\n                case 'right':\n                    return ((gestureState.moveX - gestureState.x0) /\n                        ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0));\n                default:\n                    return 0;\n            }\n        };\n        this.createAnimationEventForSwipe = () => {\n            if (this.currentSwipingDirection === 'right' ||\n                this.currentSwipingDirection === 'left') {\n                return Animated.event([null, { dx: this.state.pan.x }], {\n                    useNativeDriver: false,\n                });\n            }\n            else {\n                return Animated.event([null, { dy: this.state.pan.y }], {\n                    useNativeDriver: false,\n                });\n            }\n        };\n        this.isDirectionIncluded = (direction) => {\n            return Array.isArray(this.props.swipeDirection)\n                ? this.props.swipeDirection.includes(direction)\n                : this.props.swipeDirection === direction;\n        };\n        this.isSwipeDirectionAllowed = ({ dy, dx }) => {\n            const draggedDown = dy > 0;\n            const draggedUp = dy < 0;\n            const draggedLeft = dx < 0;\n            const draggedRight = dx > 0;\n            if (this.currentSwipingDirection === 'up' &&\n                this.isDirectionIncluded('up') &&\n                draggedUp) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'down' &&\n                this.isDirectionIncluded('down') &&\n                draggedDown) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'right' &&\n                this.isDirectionIncluded('right') &&\n                draggedRight) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'left' &&\n                this.isDirectionIncluded('left') &&\n                draggedLeft) {\n                return true;\n            }\n            return false;\n        };\n        this.handleDimensionsUpdate = () => {\n            if (!this.props.deviceHeight && !this.props.deviceWidth) {\n                // Here we update the device dimensions in the state if the layout changed\n                // (triggering a render)\n                const deviceWidth = Dimensions.get('window').width;\n                const deviceHeight = Dimensions.get('window').height;\n                if (deviceWidth !== this.state.deviceWidth ||\n                    deviceHeight !== this.state.deviceHeight) {\n                    this.setState({ deviceWidth, deviceHeight });\n                }\n            }\n        };\n        this.open = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n            }\n            // This is for resetting the pan position,otherwise the modal gets stuck\n            // at the last released position when you try to open it.\n            // TODO: Could certainly be improved - no idea for the moment.\n            if (this.state.isSwipeable) {\n                this.state.pan.setValue({ x: 0, y: 0 });\n            }\n            if (this.contentRef) {\n                this.props.onModalWillShow && this.props.onModalWillShow();\n                if (this.interactionHandle == null) {\n                    this.interactionHandle = InteractionManager.createInteractionHandle();\n                }\n                this.contentRef\n                    .animate(this.animationIn, this.props.animationInTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (this.interactionHandle) {\n                        InteractionManager.clearInteractionHandle(this.interactionHandle);\n                        this.interactionHandle = null;\n                    }\n                    if (!this.props.isVisible) {\n                        this.close();\n                    }\n                    else {\n                        this.props.onModalShow();\n                    }\n                });\n            }\n        };\n        this.close = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: 0 }, this.props.backdropTransitionOutTiming);\n            }\n            let animationOut = this.animationOut;\n            if (this.inSwipeClosingState) {\n                this.inSwipeClosingState = false;\n                if (this.currentSwipingDirection === 'up') {\n                    animationOut = 'slideOutUp';\n                }\n                else if (this.currentSwipingDirection === 'down') {\n                    animationOut = 'slideOutDown';\n                }\n                else if (this.currentSwipingDirection === 'right') {\n                    animationOut = 'slideOutRight';\n                }\n                else if (this.currentSwipingDirection === 'left') {\n                    animationOut = 'slideOutLeft';\n                }\n            }\n            if (this.contentRef) {\n                this.props.onModalWillHide && this.props.onModalWillHide();\n                if (this.interactionHandle == null) {\n                    this.interactionHandle = InteractionManager.createInteractionHandle();\n                }\n                this.contentRef\n                    .animate(animationOut, this.props.animationOutTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (this.interactionHandle) {\n                        InteractionManager.clearInteractionHandle(this.interactionHandle);\n                        this.interactionHandle = null;\n                    }\n                    if (this.props.isVisible) {\n                        this.open();\n                    }\n                    else {\n                        this.setState({\n                            showContent: false,\n                        }, () => {\n                            this.setState({\n                                isVisible: false,\n                            }, () => {\n                                this.props.onModalHide();\n                            });\n                        });\n                    }\n                });\n            }\n        };\n        this.makeBackdrop = () => {\n            if (!this.props.hasBackdrop) {\n                return null;\n            }\n            if (this.props.customBackdrop &&\n                !React.isValidElement(this.props.customBackdrop)) {\n                console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n            }\n            const { customBackdrop, backdropColor, useNativeDriver, useNativeDriverForBackdrop, onBackdropPress, } = this.props;\n            const hasCustomBackdrop = !!this.props.customBackdrop;\n            const backdropComputedStyle = [\n                {\n                    width: this.getDeviceWidth(),\n                    height: this.getDeviceHeight(),\n                    backgroundColor: this.state.showContent && !hasCustomBackdrop\n                        ? backdropColor\n                        : 'transparent',\n                },\n            ];\n            const backdropWrapper = (React.createElement(animatable.View, { ref: ref => (this.backdropRef = ref), useNativeDriver: useNativeDriverForBackdrop !== undefined\n                    ? useNativeDriverForBackdrop\n                    : useNativeDriver, style: [styles.backdrop, backdropComputedStyle] }, hasCustomBackdrop && customBackdrop));\n            if (hasCustomBackdrop) {\n                // The user will handle backdrop presses himself\n                return backdropWrapper;\n            }\n            // If there's no custom backdrop, handle presses with\n            // TouchableWithoutFeedback\n            return (React.createElement(TouchableWithoutFeedback, { onPress: onBackdropPress }, backdropWrapper));\n        };\n        const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(props));\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n        if (this.state.isSwipeable) {\n            this.state = {\n                ...this.state,\n                pan: new Animated.ValueXY(),\n            };\n            this.buildPanResponder();\n        }\n        if (props.isVisible) {\n            this.state = {\n                ...this.state,\n                isVisible: true,\n                showContent: true,\n            };\n        }\n    }\n    static getDerivedStateFromProps(nextProps, state) {\n        if (!state.isVisible && nextProps.isVisible) {\n            return { isVisible: true, showContent: true };\n        }\n        return null;\n    }\n    componentDidMount() {\n        // Show deprecation message\n        if (this.props.onSwipe) {\n            console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n        }\n        this.didUpdateDimensionsEmitter = DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n        if (this.state.isVisible) {\n            this.open();\n        }\n        BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n    }\n    componentWillUnmount() {\n        BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n        if (this.didUpdateDimensionsEmitter) {\n            this.didUpdateDimensionsEmitter.remove();\n        }\n        if (this.interactionHandle) {\n            InteractionManager.clearInteractionHandle(this.interactionHandle);\n            this.interactionHandle = null;\n        }\n    }\n    componentDidUpdate(prevProps) {\n        // If the animations have been changed then rebuild them to make sure we're\n        // using the most up-to-date ones\n        if (this.props.animationIn !== prevProps.animationIn ||\n            this.props.animationOut !== prevProps.animationOut) {\n            const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(this.props));\n            this.animationIn = animationIn;\n            this.animationOut = animationOut;\n        }\n        // If backdrop opacity has been changed then make sure to update it\n        if (this.props.backdropOpacity !== prevProps.backdropOpacity &&\n            this.backdropRef) {\n            this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n        }\n        // On modal open request, we slide the view up and fade in the backdrop\n        if (this.props.isVisible && !prevProps.isVisible) {\n            this.open();\n        }\n        else if (!this.props.isVisible && prevProps.isVisible) {\n            // On modal close request, we slide the view down and fade out the backdrop\n            this.close();\n        }\n    }\n    render() {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        const { animationIn, animationInTiming, animationOut, animationOutTiming, avoidKeyboard, coverScreen, hasBackdrop, backdropColor, backdropOpacity, backdropTransitionInTiming, backdropTransitionOutTiming, customBackdrop, children, isVisible, onModalShow, onBackButtonPress, useNativeDriver, propagateSwipe, style, ...otherProps } = this.props;\n        const { testID, ...containerProps } = otherProps;\n        const computedStyle = [\n            { margin: this.getDeviceWidth() * 0.05, transform: [{ translateY: 0 }] },\n            styles.content,\n            style,\n        ];\n        let panHandlers = {};\n        let panPosition = {};\n        if (this.state.isSwipeable) {\n            panHandlers = { ...this.panResponder.panHandlers };\n            if (useNativeDriver) {\n                panPosition = {\n                    transform: this.state.pan.getTranslateTransform(),\n                };\n            }\n            else {\n                panPosition = this.state.pan.getLayout();\n            }\n        }\n        // The user might decide not to show the modal while it is animating\n        // to enhance performance.\n        const _children = this.props.hideModalContentWhileAnimating &&\n            this.props.useNativeDriver &&\n            !this.state.showContent ? (React.createElement(animatable.View, null)) : (children);\n        const containerView = (React.createElement(animatable.View, Object.assign({}, panHandlers, { ref: ref => (this.contentRef = ref), style: [panPosition, computedStyle], pointerEvents: \"box-none\", useNativeDriver: useNativeDriver }, containerProps), _children));\n        // If coverScreen is set to false by the user\n        // we render the modal inside the parent view directly\n        if (!coverScreen && this.state.isVisible) {\n            return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.backdrop, styles.containerBox] },\n                this.makeBackdrop(),\n                containerView));\n        }\n        return (React.createElement(Modal, Object.assign({ transparent: true, animationType: 'none', visible: this.state.isVisible, onRequestClose: onBackButtonPress }, otherProps),\n            this.makeBackdrop(),\n            avoidKeyboard ? (React.createElement(KeyboardAvoidingView, { behavior: Platform.OS === 'ios' ? 'padding' : undefined, pointerEvents: \"box-none\", style: computedStyle.concat([{ margin: 0 }]) }, containerView)) : (containerView)));\n    }\n}\nReactNativeModal.propTypes = {\n    animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationInTiming: PropTypes.number,\n    animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationOutTiming: PropTypes.number,\n    avoidKeyboard: PropTypes.bool,\n    coverScreen: PropTypes.bool,\n    hasBackdrop: PropTypes.bool,\n    backdropColor: PropTypes.string,\n    backdropOpacity: PropTypes.number,\n    backdropTransitionInTiming: PropTypes.number,\n    backdropTransitionOutTiming: PropTypes.number,\n    customBackdrop: PropTypes.node,\n    children: PropTypes.node.isRequired,\n    deviceHeight: PropTypes.number,\n    deviceWidth: PropTypes.number,\n    isVisible: PropTypes.bool.isRequired,\n    hideModalContentWhileAnimating: PropTypes.bool,\n    propagateSwipe: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    onModalShow: PropTypes.func,\n    onModalWillShow: PropTypes.func,\n    onModalHide: PropTypes.func,\n    onModalWillHide: PropTypes.func,\n    onBackButtonPress: PropTypes.func,\n    onBackdropPress: PropTypes.func,\n    panResponderThreshold: PropTypes.number,\n    onSwipeStart: PropTypes.func,\n    onSwipeMove: PropTypes.func,\n    onSwipeComplete: PropTypes.func,\n    onSwipeCancel: PropTypes.func,\n    swipeThreshold: PropTypes.number,\n    swipeDirection: PropTypes.oneOfType([\n        PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])),\n        PropTypes.oneOf(['up', 'down', 'left', 'right']),\n    ]),\n    useNativeDriver: PropTypes.bool,\n    useNativeDriverForBackdrop: PropTypes.bool,\n    style: PropTypes.any,\n    scrollTo: PropTypes.func,\n    scrollOffset: PropTypes.number,\n    scrollOffsetMax: PropTypes.number,\n    scrollHorizontal: PropTypes.bool,\n    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf([\n        'portrait',\n        'portrait-upside-down',\n        'landscape',\n        'landscape-left',\n        'landscape-right',\n    ])),\n};\nReactNativeModal.defaultProps = defaultProps;\nexport default ReactNativeModal;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}