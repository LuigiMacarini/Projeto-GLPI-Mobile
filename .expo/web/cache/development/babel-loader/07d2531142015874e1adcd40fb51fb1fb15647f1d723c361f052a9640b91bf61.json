{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _jsxFileName = \"/home/luigi/\\xC1rea de Trabalho/glpi-app-react/node_modules/react-native-modal/node_modules/react-native-animatable/createAnimatableComponent.js\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport wrapStyleTransforms from './wrapStyleTransforms';\nimport getStyleValues from './getStyleValues';\nimport flattenStyle from './flattenStyle';\nimport createAnimation from './createAnimation';\nimport { getAnimationByName, getAnimationNames } from './registry';\nimport EASING_FUNCTIONS from './easing';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst INTERPOLATION_STYLE_PROPERTIES = ['rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'transformMatrix', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'shadowColor', 'color', 'textDecorationColor', 'tintColor'];\nconst ZERO_CLAMPED_STYLE_PROPERTIES = ['width', 'height'];\nfunction omit(keys, source) {\n  const filtered = {};\n  Object.keys(source).forEach(key => {\n    if (keys.indexOf(key) === -1) {\n      filtered[key] = source[key];\n    }\n  });\n  return filtered;\n}\nfunction deepEquals(a, b) {\n  return a === b || JSON.stringify(a) === JSON.stringify(b);\n}\nfunction getAnimationTarget(iteration, direction) {\n  switch (direction) {\n    case 'reverse':\n      return 0;\n    case 'alternate':\n      return iteration % 2 ? 0 : 1;\n    case 'alternate-reverse':\n      return iteration % 2 ? 1 : 0;\n    case 'normal':\n    default:\n      return 1;\n  }\n}\nfunction getAnimationOrigin(iteration, direction) {\n  return getAnimationTarget(iteration, direction) ? 0 : 1;\n}\nfunction getCompiledAnimation(animation) {\n  if (typeof animation === 'string') {\n    const compiledAnimation = getAnimationByName(animation);\n    if (!compiledAnimation) {\n      throw new Error(`No animation registred by the name of ${animation}`);\n    }\n    return compiledAnimation;\n  }\n  return createAnimation(animation);\n}\nfunction makeInterpolatedStyle(compiledAnimation, animationValue) {\n  const style = {};\n  Object.keys(compiledAnimation).forEach(key => {\n    if (key === 'style') {\n      Object.assign(style, compiledAnimation.style);\n    } else if (key !== 'easing') {\n      style[key] = animationValue.interpolate(compiledAnimation[key]);\n    }\n  });\n  return wrapStyleTransforms(style);\n}\nfunction transitionToValue(property, transitionValue, toValue, duration, easing, useNativeDriver = false, delay, onTransitionBegin, onTransitionEnd) {\n  const animation = duration || easing || delay ? Animated.timing(transitionValue, {\n    toValue,\n    delay,\n    duration: duration || 1000,\n    easing: typeof easing === 'function' ? easing : EASING_FUNCTIONS[easing || 'ease'],\n    useNativeDriver\n  }) : Animated.spring(transitionValue, {\n    toValue,\n    useNativeDriver\n  });\n  setTimeout(() => onTransitionBegin(property), delay);\n  animation.start(() => onTransitionEnd(property));\n}\nexport default function createAnimatableComponent(WrappedComponent) {\n  const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  const Animatable = Animated.createAnimatedComponent(WrappedComponent);\n  return class AnimatableComponent extends Component {\n    static displayName = `withAnimatable(${wrappedComponentName})`;\n    static propTypes = {\n      animation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n      duration: PropTypes.number,\n      direction: PropTypes.oneOf(['normal', 'reverse', 'alternate', 'alternate-reverse']),\n      delay: PropTypes.number,\n      easing: PropTypes.oneOfType([PropTypes.oneOf(Object.keys(EASING_FUNCTIONS)), PropTypes.func]),\n      iterationCount(props, propName) {\n        const val = props[propName];\n        if (val !== 'infinite' && !(typeof val === 'number' && val >= 1)) {\n          return new Error('iterationCount must be a positive number or \"infinite\"');\n        }\n        return null;\n      },\n      iterationDelay: PropTypes.number,\n      onAnimationBegin: PropTypes.func,\n      onAnimationEnd: PropTypes.func,\n      onTransitionBegin: PropTypes.func,\n      onTransitionEnd: PropTypes.func,\n      style: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.object]),\n      transition: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n      useNativeDriver: PropTypes.bool\n    };\n    static defaultProps = {\n      animation: undefined,\n      delay: 0,\n      direction: 'normal',\n      duration: undefined,\n      easing: undefined,\n      iterationCount: 1,\n      iterationDelay: 0,\n      onAnimationBegin() {},\n      onAnimationEnd() {},\n      onTransitionBegin() {},\n      onTransitionEnd() {},\n      style: undefined,\n      transition: undefined,\n      useNativeDriver: false\n    };\n    constructor(props) {\n      super(props);\n      const animationValue = new Animated.Value(getAnimationOrigin(0, this.props.direction));\n      let animationStyle = {};\n      let compiledAnimation = {};\n      if (props.animation) {\n        compiledAnimation = getCompiledAnimation(props.animation);\n        animationStyle = makeInterpolatedStyle(compiledAnimation, animationValue);\n      }\n      this.state = {\n        animationValue,\n        animationStyle,\n        compiledAnimation,\n        transitionStyle: {},\n        transitionValues: {},\n        currentTransitionValues: {}\n      };\n      if (props.transition) {\n        this.state = _objectSpread(_objectSpread({}, this.state), this.initializeTransitionState(props.transition));\n      }\n      this.delayTimer = null;\n      getAnimationNames().forEach(animationName => {\n        if (!(animationName in this)) {\n          this[animationName] = this.animate.bind(this, animationName);\n        }\n      });\n    }\n    initializeTransitionState(transitionKeys) {\n      const transitionValues = {};\n      const styleValues = {};\n      const currentTransitionValues = getStyleValues(transitionKeys, this.props.style);\n      Object.keys(currentTransitionValues).forEach(key => {\n        const value = currentTransitionValues[key];\n        if (INTERPOLATION_STYLE_PROPERTIES.indexOf(key) !== -1 || typeof value !== 'number') {\n          transitionValues[key] = new Animated.Value(0);\n          styleValues[key] = value;\n        } else {\n          const animationValue = new Animated.Value(value);\n          transitionValues[key] = animationValue;\n          styleValues[key] = animationValue;\n        }\n      });\n      return {\n        currentTransitionValues,\n        transitionStyle: styleValues,\n        transitionValues\n      };\n    }\n    getTransitionState(keys) {\n      const transitionKeys = typeof keys === 'string' ? [keys] : keys;\n      let {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      } = this.state;\n      const missingKeys = transitionKeys.filter(key => !this.state.transitionValues[key]);\n      if (missingKeys.length) {\n        const transitionState = this.initializeTransitionState(missingKeys);\n        transitionValues = _objectSpread(_objectSpread({}, transitionValues), transitionState.transitionValues);\n        currentTransitionValues = _objectSpread(_objectSpread({}, currentTransitionValues), transitionState.currentTransitionValues);\n        transitionStyle = _objectSpread(_objectSpread({}, transitionStyle), transitionState.transitionStyle);\n      }\n      return {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      };\n    }\n    ref = null;\n    handleRef = ref => {\n      this.ref = ref;\n    };\n    setNativeProps(nativeProps) {\n      if (this.ref) {\n        this.ref.setNativeProps(nativeProps);\n      }\n    }\n    componentDidMount() {\n      const {\n        animation,\n        duration,\n        delay,\n        onAnimationBegin,\n        iterationDelay\n      } = this.props;\n      if (animation) {\n        const startAnimation = () => {\n          onAnimationBegin();\n          this.startAnimation(duration, 0, iterationDelay, endState => this.props.onAnimationEnd(endState));\n          this.delayTimer = null;\n        };\n        if (delay) {\n          this.delayTimer = setTimeout(startAnimation, delay);\n        } else {\n          startAnimation();\n        }\n      }\n    }\n    UNSAFE_componentWillReceiveProps(props) {\n      const {\n        animation,\n        delay,\n        duration,\n        easing,\n        iterationDelay,\n        transition,\n        onAnimationBegin\n      } = props;\n      if (transition) {\n        const values = getStyleValues(transition, props.style);\n        this.transitionTo(values, duration, easing, delay);\n      } else if (!deepEquals(animation, this.props.animation)) {\n        if (animation) {\n          if (this.delayTimer) {\n            this.setAnimation(animation);\n          } else {\n            onAnimationBegin();\n            this.animate(animation, duration, iterationDelay).then(endState => this.props.onAnimationEnd(endState));\n          }\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n    componentWillUnmount() {\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n    }\n    setAnimation(animation, callback) {\n      const compiledAnimation = getCompiledAnimation(animation);\n      this.setState(state => ({\n        animationStyle: makeInterpolatedStyle(compiledAnimation, state.animationValue),\n        compiledAnimation\n      }), callback);\n    }\n    animate(animation, duration, iterationDelay) {\n      return new Promise(resolve => {\n        this.setAnimation(animation, () => {\n          this.startAnimation(duration, 0, iterationDelay, resolve);\n        });\n      });\n    }\n    stopAnimation() {\n      this.setState({\n        scheduledAnimation: false,\n        animationStyle: {}\n      });\n      this.state.animationValue.stopAnimation();\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n        this.delayTimer = null;\n      }\n    }\n    startAnimation(duration, iteration, iterationDelay, callback) {\n      const {\n        animationValue,\n        compiledAnimation\n      } = this.state;\n      const {\n        direction,\n        iterationCount,\n        useNativeDriver\n      } = this.props;\n      let easing = this.props.easing || compiledAnimation.easing || 'ease';\n      let currentIteration = iteration || 0;\n      const fromValue = getAnimationOrigin(currentIteration, direction);\n      const toValue = getAnimationTarget(currentIteration, direction);\n      animationValue.setValue(fromValue);\n      if (typeof easing === 'string') {\n        easing = EASING_FUNCTIONS[easing];\n      }\n      const reversed = direction === 'reverse' || direction === 'alternate' && !toValue || direction === 'alternate-reverse' && !toValue;\n      if (reversed) {\n        easing = Easing.out(easing);\n      }\n      const config = {\n        toValue,\n        easing,\n        isInteraction: iterationCount <= 1,\n        duration: duration || this.props.duration || 1000,\n        useNativeDriver,\n        delay: iterationDelay || 0\n      };\n      Animated.timing(animationValue, config).start(endState => {\n        currentIteration += 1;\n        if (endState.finished && this.props.animation && (iterationCount === 'infinite' || currentIteration < iterationCount)) {\n          this.startAnimation(duration, currentIteration, iterationDelay, callback);\n        } else if (callback) {\n          callback(endState);\n        }\n      });\n    }\n    transition(fromValues, toValues, duration, easing) {\n      const fromValuesFlat = flattenStyle(fromValues);\n      const toValuesFlat = flattenStyle(toValues);\n      const transitionKeys = Object.keys(toValuesFlat);\n      const {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      } = this.getTransitionState(transitionKeys);\n      transitionKeys.forEach(property => {\n        const fromValue = fromValuesFlat[property];\n        const toValue = toValuesFlat[property];\n        let transitionValue = transitionValues[property];\n        if (!transitionValue) {\n          transitionValue = new Animated.Value(0);\n        }\n        const needsInterpolation = INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof value !== 'number';\n        const needsZeroClamping = ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        if (needsInterpolation) {\n          transitionValue.setValue(0);\n          transitionStyle[property] = transitionValue.interpolate({\n            inputRange: [0, 1],\n            outputRange: [fromValue, toValue]\n          });\n          currentTransitionValues[property] = toValue;\n          toValuesFlat[property] = 1;\n        } else {\n          if (needsZeroClamping) {\n            transitionStyle[property] = transitionValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, 1],\n              extrapolateLeft: 'clamp'\n            });\n            currentTransitionValues[property] = toValue;\n          } else {\n            transitionStyle[property] = transitionValue;\n          }\n          transitionValue.setValue(fromValue);\n        }\n      });\n      this.setState({\n        transitionValues,\n        transitionStyle,\n        currentTransitionValues\n      }, () => {\n        this.transitionToValues(toValuesFlat, duration || this.props.duration, easing, this.props.delay);\n      });\n    }\n    transitionTo(toValues, duration, easing, delay) {\n      const {\n        currentTransitionValues\n      } = this.state;\n      const toValuesFlat = flattenStyle(toValues);\n      const transitions = {\n        from: {},\n        to: {}\n      };\n      Object.keys(toValuesFlat).forEach(property => {\n        const toValue = toValuesFlat[property];\n        const needsInterpolation = INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof value !== 'number';\n        const needsZeroClamping = ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        const transitionStyle = this.state.transitionStyle[property];\n        const transitionValue = this.state.transitionValues[property];\n        if (!needsInterpolation && !needsZeroClamping && transitionStyle && transitionStyle === transitionValue) {\n          transitionToValue(property, transitionValue, toValue, duration, easing, this.props.useNativeDriver, delay, prop => this.props.onTransitionBegin(prop), prop => this.props.onTransitionEnd(prop));\n        } else {\n          let currentTransitionValue = currentTransitionValues[property];\n          if (typeof currentTransitionValue === 'undefined' && this.props.style) {\n            const style = getStyleValues(property, this.props.style);\n            currentTransitionValue = style[property];\n          }\n          transitions.from[property] = currentTransitionValue;\n          transitions.to[property] = toValue;\n        }\n      });\n      if (Object.keys(transitions.from).length) {\n        this.transition(transitions.from, transitions.to, duration, easing);\n      }\n    }\n    transitionToValues(toValues, duration, easing, delay) {\n      Object.keys(toValues).forEach(property => {\n        const transitionValue = this.state.transitionValues[property];\n        const toValue = toValues[property];\n        transitionToValue(property, transitionValue, toValue, duration, easing, this.props.useNativeDriver, delay, prop => this.props.onTransitionBegin(prop), prop => this.props.onTransitionEnd(prop));\n      });\n    }\n    render() {\n      const {\n        style,\n        animation,\n        transition\n      } = this.props;\n      if (animation && transition) {\n        throw new Error('You cannot combine animation and transition props');\n      }\n      const restProps = omit(['animation', 'duration', 'direction', 'delay', 'easing', 'iterationCount', 'iterationDelay', 'onAnimationBegin', 'onAnimationEnd', 'onTransitionBegin', 'onTransitionEnd', 'style', 'transition', 'useNativeDriver'], this.props);\n      return _jsxDEV(Animatable, _objectSpread({\n        ref: this.handleRef,\n        style: [style, this.state.animationStyle, wrapStyleTransforms(this.state.transitionStyle)]\n      }, restProps), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 599,\n        columnNumber: 9\n      }, this);\n    }\n  };\n}","map":{"version":3,"names":["React","Component","PropTypes","Animated","Easing","wrapStyleTransforms","getStyleValues","flattenStyle","createAnimation","getAnimationByName","getAnimationNames","EASING_FUNCTIONS","jsxDEV","_jsxDEV","INTERPOLATION_STYLE_PROPERTIES","ZERO_CLAMPED_STYLE_PROPERTIES","omit","keys","source","filtered","Object","forEach","key","indexOf","deepEquals","a","b","JSON","stringify","getAnimationTarget","iteration","direction","getAnimationOrigin","getCompiledAnimation","animation","compiledAnimation","Error","makeInterpolatedStyle","animationValue","style","assign","interpolate","transitionToValue","property","transitionValue","toValue","duration","easing","useNativeDriver","delay","onTransitionBegin","onTransitionEnd","timing","spring","setTimeout","start","createAnimatableComponent","WrappedComponent","wrappedComponentName","displayName","name","Animatable","createAnimatedComponent","AnimatableComponent","propTypes","oneOfType","string","object","number","oneOf","func","iterationCount","props","propName","val","iterationDelay","onAnimationBegin","onAnimationEnd","array","transition","arrayOf","bool","defaultProps","undefined","constructor","Value","animationStyle","state","transitionStyle","transitionValues","currentTransitionValues","_objectSpread","initializeTransitionState","delayTimer","animationName","animate","bind","transitionKeys","styleValues","value","getTransitionState","missingKeys","filter","length","transitionState","ref","handleRef","setNativeProps","nativeProps","componentDidMount","startAnimation","endState","UNSAFE_componentWillReceiveProps","values","transitionTo","setAnimation","then","stopAnimation","componentWillUnmount","clearTimeout","callback","setState","Promise","resolve","scheduledAnimation","currentIteration","fromValue","setValue","reversed","out","config","isInteraction","finished","fromValues","toValues","fromValuesFlat","toValuesFlat","needsInterpolation","needsZeroClamping","inputRange","outputRange","extrapolateLeft","transitionToValues","transitions","from","to","prop","currentTransitionValue","render","restProps","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/luigi/Ãrea de Trabalho/glpi-app-react/node_modules/react-native-modal/node_modules/react-native-animatable/createAnimatableComponent.js"],"sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Animated, Easing } from 'react-native';\nimport wrapStyleTransforms from './wrapStyleTransforms';\nimport getStyleValues from './getStyleValues';\nimport flattenStyle from './flattenStyle';\nimport createAnimation from './createAnimation';\nimport { getAnimationByName, getAnimationNames } from './registry';\nimport EASING_FUNCTIONS from './easing';\n\n// These styles are not number based and thus needs to be interpolated\nconst INTERPOLATION_STYLE_PROPERTIES = [\n  // Transform styles\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'skewX',\n  'skewY',\n  'transformMatrix',\n  // View styles\n  'backgroundColor',\n  'borderColor',\n  'borderTopColor',\n  'borderRightColor',\n  'borderBottomColor',\n  'borderLeftColor',\n  'shadowColor',\n  // Text styles\n  'color',\n  'textDecorationColor',\n  // Image styles\n  'tintColor',\n];\n\nconst ZERO_CLAMPED_STYLE_PROPERTIES = ['width', 'height'];\n\n// Create a copy of `source` without `keys`\nfunction omit(keys, source) {\n  const filtered = {};\n  Object.keys(source).forEach(key => {\n    if (keys.indexOf(key) === -1) {\n      filtered[key] = source[key];\n    }\n  });\n  return filtered;\n}\n\n// Yes it's absurd, but actually fast\nfunction deepEquals(a, b) {\n  return a === b || JSON.stringify(a) === JSON.stringify(b);\n}\n\n// Determine to what value the animation should tween to\nfunction getAnimationTarget(iteration, direction) {\n  switch (direction) {\n    case 'reverse':\n      return 0;\n    case 'alternate':\n      return iteration % 2 ? 0 : 1;\n    case 'alternate-reverse':\n      return iteration % 2 ? 1 : 0;\n    case 'normal':\n    default:\n      return 1;\n  }\n}\n\n// Like getAnimationTarget but opposite\nfunction getAnimationOrigin(iteration, direction) {\n  return getAnimationTarget(iteration, direction) ? 0 : 1;\n}\n\nfunction getCompiledAnimation(animation) {\n  if (typeof animation === 'string') {\n    const compiledAnimation = getAnimationByName(animation);\n    if (!compiledAnimation) {\n      throw new Error(`No animation registred by the name of ${animation}`);\n    }\n    return compiledAnimation;\n  }\n  return createAnimation(animation);\n}\n\nfunction makeInterpolatedStyle(compiledAnimation, animationValue) {\n  const style = {};\n  Object.keys(compiledAnimation).forEach(key => {\n    if (key === 'style') {\n      Object.assign(style, compiledAnimation.style);\n    } else if (key !== 'easing') {\n      style[key] = animationValue.interpolate(compiledAnimation[key]);\n    }\n  });\n  return wrapStyleTransforms(style);\n}\n\nfunction transitionToValue(\n  property,\n  transitionValue,\n  toValue,\n  duration,\n  easing,\n  useNativeDriver = false,\n  delay,\n  onTransitionBegin,\n  onTransitionEnd,\n) {\n  const animation =\n    duration || easing || delay\n      ? Animated.timing(transitionValue, {\n          toValue,\n          delay,\n          duration: duration || 1000,\n          easing:\n            typeof easing === 'function'\n              ? easing\n              : EASING_FUNCTIONS[easing || 'ease'],\n          useNativeDriver,\n        })\n      : Animated.spring(transitionValue, { toValue, useNativeDriver });\n  setTimeout(() => onTransitionBegin(property), delay);\n  animation.start(() => onTransitionEnd(property));\n}\n\n// Make (almost) any component animatable, similar to Animated.createAnimatedComponent\nexport default function createAnimatableComponent(WrappedComponent) {\n  const wrappedComponentName =\n    WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\n  const Animatable = Animated.createAnimatedComponent(WrappedComponent);\n\n  return class AnimatableComponent extends Component {\n    static displayName = `withAnimatable(${wrappedComponentName})`;\n\n    static propTypes = {\n      animation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n      duration: PropTypes.number,\n      direction: PropTypes.oneOf([\n        'normal',\n        'reverse',\n        'alternate',\n        'alternate-reverse',\n      ]),\n      delay: PropTypes.number,\n      easing: PropTypes.oneOfType([\n        PropTypes.oneOf(Object.keys(EASING_FUNCTIONS)),\n        PropTypes.func,\n      ]),\n      iterationCount(props, propName) {\n        const val = props[propName];\n        if (val !== 'infinite' && !(typeof val === 'number' && val >= 1)) {\n          return new Error(\n            'iterationCount must be a positive number or \"infinite\"',\n          );\n        }\n        return null;\n      },\n      iterationDelay: PropTypes.number,\n      onAnimationBegin: PropTypes.func,\n      onAnimationEnd: PropTypes.func,\n      onTransitionBegin: PropTypes.func,\n      onTransitionEnd: PropTypes.func,\n      style: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.array,\n        PropTypes.object,\n      ]),\n      transition: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.arrayOf(PropTypes.string),\n      ]),\n      useNativeDriver: PropTypes.bool,\n    };\n\n    static defaultProps = {\n      animation: undefined,\n      delay: 0,\n      direction: 'normal',\n      duration: undefined,\n      easing: undefined,\n      iterationCount: 1,\n      iterationDelay: 0,\n      onAnimationBegin() {},\n      onAnimationEnd() {},\n      onTransitionBegin() {},\n      onTransitionEnd() {},\n      style: undefined,\n      transition: undefined,\n      useNativeDriver: false,\n    };\n\n    constructor(props) {\n      super(props);\n\n      const animationValue = new Animated.Value(\n        getAnimationOrigin(0, this.props.direction),\n      );\n      let animationStyle = {};\n      let compiledAnimation = {};\n      if (props.animation) {\n        compiledAnimation = getCompiledAnimation(props.animation);\n        animationStyle = makeInterpolatedStyle(\n          compiledAnimation,\n          animationValue,\n        );\n      }\n      this.state = {\n        animationValue,\n        animationStyle,\n        compiledAnimation,\n        transitionStyle: {},\n        transitionValues: {},\n        currentTransitionValues: {},\n      };\n\n      if (props.transition) {\n        this.state = {\n          ...this.state,\n          ...this.initializeTransitionState(props.transition),\n        };\n      }\n      this.delayTimer = null;\n\n      // Alias registered animations for backwards compatibility\n      getAnimationNames().forEach(animationName => {\n        if (!(animationName in this)) {\n          this[animationName] = this.animate.bind(this, animationName);\n        }\n      });\n    }\n\n    initializeTransitionState(transitionKeys) {\n      const transitionValues = {};\n      const styleValues = {};\n\n      const currentTransitionValues = getStyleValues(\n        transitionKeys,\n        this.props.style,\n      );\n      Object.keys(currentTransitionValues).forEach(key => {\n        const value = currentTransitionValues[key];\n        if (\n          INTERPOLATION_STYLE_PROPERTIES.indexOf(key) !== -1 ||\n          typeof value !== 'number'\n        ) {\n          transitionValues[key] = new Animated.Value(0);\n          styleValues[key] = value;\n        } else {\n          const animationValue = new Animated.Value(value);\n          transitionValues[key] = animationValue;\n          styleValues[key] = animationValue;\n        }\n      });\n\n      return {\n        currentTransitionValues,\n        transitionStyle: styleValues,\n        transitionValues,\n      };\n    }\n\n    getTransitionState(keys) {\n      const transitionKeys = typeof keys === 'string' ? [keys] : keys;\n      let {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle,\n      } = this.state;\n      const missingKeys = transitionKeys.filter(\n        key => !this.state.transitionValues[key],\n      );\n      if (missingKeys.length) {\n        const transitionState = this.initializeTransitionState(missingKeys);\n        transitionValues = {\n          ...transitionValues,\n          ...transitionState.transitionValues,\n        };\n        currentTransitionValues = {\n          ...currentTransitionValues,\n          ...transitionState.currentTransitionValues,\n        };\n        transitionStyle = {\n          ...transitionStyle,\n          ...transitionState.transitionStyle,\n        };\n      }\n      return { transitionValues, currentTransitionValues, transitionStyle };\n    }\n\n    ref = null;\n\n    handleRef = ref => {\n      this.ref = ref;\n    };\n\n    setNativeProps(nativeProps) {\n      if (this.ref) {\n        this.ref.setNativeProps(nativeProps);\n      }\n    }\n\n    componentDidMount() {\n      const {\n        animation,\n        duration,\n        delay,\n        onAnimationBegin,\n        iterationDelay,\n      } = this.props;\n      if (animation) {\n        const startAnimation = () => {\n          onAnimationBegin();\n          this.startAnimation(duration, 0, iterationDelay, endState =>\n            this.props.onAnimationEnd(endState),\n          );\n          this.delayTimer = null;\n        };\n        if (delay) {\n          this.delayTimer = setTimeout(startAnimation, delay);\n        } else {\n          startAnimation();\n        }\n      }\n    }\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillReceiveProps(props) {\n      const {\n        animation,\n        delay,\n        duration,\n        easing,\n        iterationDelay,\n        transition,\n        onAnimationBegin,\n      } = props;\n\n      if (transition) {\n        const values = getStyleValues(transition, props.style);\n        this.transitionTo(values, duration, easing, delay);\n      } else if (!deepEquals(animation, this.props.animation)) {\n        if (animation) {\n          if (this.delayTimer) {\n            this.setAnimation(animation);\n          } else {\n            onAnimationBegin();\n            this.animate(animation, duration, iterationDelay).then(endState =>\n              this.props.onAnimationEnd(endState),\n            );\n          }\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n\n    componentWillUnmount() {\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n    }\n\n    setAnimation(animation, callback) {\n      const compiledAnimation = getCompiledAnimation(animation);\n      this.setState(\n        state => ({\n          animationStyle: makeInterpolatedStyle(\n            compiledAnimation,\n            state.animationValue,\n          ),\n          compiledAnimation,\n        }),\n        callback,\n      );\n    }\n\n    animate(animation, duration, iterationDelay) {\n      return new Promise(resolve => {\n        this.setAnimation(animation, () => {\n          this.startAnimation(duration, 0, iterationDelay, resolve);\n        });\n      });\n    }\n\n    stopAnimation() {\n      this.setState({\n        scheduledAnimation: false,\n        animationStyle: {},\n      });\n      this.state.animationValue.stopAnimation();\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n        this.delayTimer = null;\n      }\n    }\n\n    startAnimation(duration, iteration, iterationDelay, callback) {\n      const { animationValue, compiledAnimation } = this.state;\n      const { direction, iterationCount, useNativeDriver } = this.props;\n      let easing = this.props.easing || compiledAnimation.easing || 'ease';\n      let currentIteration = iteration || 0;\n      const fromValue = getAnimationOrigin(currentIteration, direction);\n      const toValue = getAnimationTarget(currentIteration, direction);\n      animationValue.setValue(fromValue);\n\n      if (typeof easing === 'string') {\n        easing = EASING_FUNCTIONS[easing];\n      }\n      // Reverse easing if on the way back\n      const reversed =\n        direction === 'reverse' ||\n        (direction === 'alternate' && !toValue) ||\n        (direction === 'alternate-reverse' && !toValue);\n      if (reversed) {\n        easing = Easing.out(easing);\n      }\n      const config = {\n        toValue,\n        easing,\n        isInteraction: iterationCount <= 1,\n        duration: duration || this.props.duration || 1000,\n        useNativeDriver,\n        delay: iterationDelay || 0,\n      };\n\n      Animated.timing(animationValue, config).start(endState => {\n        currentIteration += 1;\n        if (\n          endState.finished &&\n          this.props.animation &&\n          (iterationCount === 'infinite' || currentIteration < iterationCount)\n        ) {\n          this.startAnimation(\n            duration,\n            currentIteration,\n            iterationDelay,\n            callback,\n          );\n        } else if (callback) {\n          callback(endState);\n        }\n      });\n    }\n\n    transition(fromValues, toValues, duration, easing) {\n      const fromValuesFlat = flattenStyle(fromValues);\n      const toValuesFlat = flattenStyle(toValues);\n      const transitionKeys = Object.keys(toValuesFlat);\n      const {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle,\n      } = this.getTransitionState(transitionKeys);\n\n      transitionKeys.forEach(property => {\n        const fromValue = fromValuesFlat[property];\n        const toValue = toValuesFlat[property];\n        let transitionValue = transitionValues[property];\n        if (!transitionValue) {\n          transitionValue = new Animated.Value(0);\n        }\n        const needsInterpolation =\n          INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 ||\n          typeof value !== 'number';\n        const needsZeroClamping =\n          ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        if (needsInterpolation) {\n          transitionValue.setValue(0);\n          transitionStyle[property] = transitionValue.interpolate({\n            inputRange: [0, 1],\n            outputRange: [fromValue, toValue],\n          });\n          currentTransitionValues[property] = toValue;\n          toValuesFlat[property] = 1;\n        } else {\n          if (needsZeroClamping) {\n            transitionStyle[property] = transitionValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, 1],\n              extrapolateLeft: 'clamp',\n            });\n            currentTransitionValues[property] = toValue;\n          } else {\n            transitionStyle[property] = transitionValue;\n          }\n          transitionValue.setValue(fromValue);\n        }\n      });\n      this.setState(\n        { transitionValues, transitionStyle, currentTransitionValues },\n        () => {\n          this.transitionToValues(\n            toValuesFlat,\n            duration || this.props.duration,\n            easing,\n            this.props.delay,\n          );\n        },\n      );\n    }\n\n    transitionTo(toValues, duration, easing, delay) {\n      const { currentTransitionValues } = this.state;\n      const toValuesFlat = flattenStyle(toValues);\n      const transitions = {\n        from: {},\n        to: {},\n      };\n\n      Object.keys(toValuesFlat).forEach(property => {\n        const toValue = toValuesFlat[property];\n        const needsInterpolation =\n          INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 ||\n          typeof value !== 'number';\n        const needsZeroClamping =\n          ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        const transitionStyle = this.state.transitionStyle[property];\n        const transitionValue = this.state.transitionValues[property];\n        if (\n          !needsInterpolation &&\n          !needsZeroClamping &&\n          transitionStyle &&\n          transitionStyle === transitionValue\n        ) {\n          transitionToValue(\n            property,\n            transitionValue,\n            toValue,\n            duration,\n            easing,\n            this.props.useNativeDriver,\n            delay,\n            prop => this.props.onTransitionBegin(prop),\n            prop => this.props.onTransitionEnd(prop),\n          );\n        } else {\n          let currentTransitionValue = currentTransitionValues[property];\n          if (\n            typeof currentTransitionValue === 'undefined' &&\n            this.props.style\n          ) {\n            const style = getStyleValues(property, this.props.style);\n            currentTransitionValue = style[property];\n          }\n          transitions.from[property] = currentTransitionValue;\n          transitions.to[property] = toValue;\n        }\n      });\n\n      if (Object.keys(transitions.from).length) {\n        this.transition(transitions.from, transitions.to, duration, easing);\n      }\n    }\n\n    transitionToValues(toValues, duration, easing, delay) {\n      Object.keys(toValues).forEach(property => {\n        const transitionValue = this.state.transitionValues[property];\n        const toValue = toValues[property];\n        transitionToValue(\n          property,\n          transitionValue,\n          toValue,\n          duration,\n          easing,\n          this.props.useNativeDriver,\n          delay,\n          prop => this.props.onTransitionBegin(prop),\n          prop => this.props.onTransitionEnd(prop),\n        );\n      });\n    }\n\n    render() {\n      const { style, animation, transition } = this.props;\n      if (animation && transition) {\n        throw new Error('You cannot combine animation and transition props');\n      }\n      const restProps = omit(\n        [\n          'animation',\n          'duration',\n          'direction',\n          'delay',\n          'easing',\n          'iterationCount',\n          'iterationDelay',\n          'onAnimationBegin',\n          'onAnimationEnd',\n          'onTransitionBegin',\n          'onTransitionEnd',\n          'style',\n          'transition',\n          'useNativeDriver',\n        ],\n        this.props,\n      );\n\n      return (\n        <Animatable\n          ref={this.handleRef}\n          style={[\n            style,\n            this.state.animationStyle,\n            wrapStyleTransforms(this.state.transitionStyle),\n          ]}\n          {...restProps}\n        />\n      );\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}